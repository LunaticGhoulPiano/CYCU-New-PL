3
; just concatenate test1 and test2
; test 1
; test operations
; pure int
(> 5 3)
(< -1 0)
(= 42 42)
(<= 2 2)
(>= -10 -20)
; pure float
(> 3.1 2.9)
(< -0.5 0.0)
(= 1.234 1.234)
(<= 0.0001 0.0002)
(>= -1.5 -3.0)
; int & float
(> 5 4.5)
(< 1.0 2)
(= 7.0 7)
(<= 2 2.5)
(>= -3.0 -3)
; multi-operands
(> 9 8 7 6 5)
(< -5 -3 -1 0)
(= 2 2 2 2 2)
(<= 1 2 3 4 5)
(>= 5 5 5 5 5)
(< -1.1 0.0 1.1 2.2 3.3)
(> 9 8 7 10 5)
(< 0 1 2 3 2)
(= 1 1 2 1)
; positive & negative
(> 10 -1)
(< -9 0 9)
(= -2.5 -2.5)
(<= -10 -10 0 10)
(>= 100 -50 -100)
; logical
(and (> 5 4) (< 1 2))
(or (= 3 3) (> 1 2))
(not (> 2 5)) ; ➜ #t
(not (< 1 2)) ; ➜ nil
; complex
(not
  (or
    (and
      (> 1 2 3)
      (not (<= 1.2 3 0 14 2444 32323.440394))
    )
    (or
      (> 1 23)
      (< 0 9.123 -9 3902)
    )
    (<= 1.2 3 0 14 2444 32323.440394)
  )
)
(not
  (and
    (and
      (> 1 2 3)
      (not (<= 1.2 3 0 14 2444 32323.440394))
    )
    (or
      (> 1 23)
      (< 0 9.123 -9 3902)
    )
    (<= 1.2 3 0 14 2444 32323.440394)
  )
)
(not
  (or
    (or
      (> 1 2 3)
      (not (<= 1.2 3 0 14 2444 32323.440394))
    )
    (or
      (> 1 23)
      (< 0 9.123 -9 3902)
    )
    (<= 1.2 3 0 14 2444 32323.440394)
  )
)
; strings
(string-append "Hello," " there!")
(string-append "Hello," " there!" " Wait!")
(string>? "az" "aw")
(string<? "az" "aw")
(string=? "az" "aw")
(string=? "az" (string-append "a" "z"))
(string>? "az" "aw" "ax")
(string<? "az" "aw" "ax")
(string=? "az" "aw" "ax")
(string>? "az" "aw" "atuv")
(string>? "hi" "there" about)
(string>? "hi" "there" about a)
; test 2
; construct & get part & quote & exit & define (level error) & clean-environment
(cons 1 2)
(cons 1 2 3)
(list)
(list list cons car cdr)
(cons (list) (list car cdr (car (list 1 2 3) (cdr (list 2 3 4)))))
(car (list car cdr nil t "" 'test ))
'(quote car cdr test hahaha test fffffffuclllllllllllllicking useless PL shits)
''''''''''''''''''''a'''a
(car (cdr '(nil t '(test quote 1 2 3) (quote (1 2 3 )))))
(cons car (car (cdr (list 1 2))))
(exit 20)
(car (cons (exit 20) (+ 5 3)))
(car (cons (define abc 20) (+ 5 3)))
(car (cons (exit 20)))
(clean-environment 1 23)
(clean-environment)
(begin (clean-environment) (exit) 0)
(begin 1 2 3)
(begin (car (cons (+ 5 (car '(10 20))) (exit 20))) (+ 789 456 123 (- 456 789 1.0) (* 1. 0. 6) (/ 0.8 0.999)))
(begin (car (cons (+ 5 (car '(10 20))) (list 20))) (+ 789 456 123 (- 456 789 1.0) (* 1. 0. 6) (/ 0.8 0.999)))
(begin (car (cons (+ 5 (car '(10 20))) (list 20))) (+ 789 456 123 (- 456 789 1.0) (* 1. 0. 6) (/ 0.8 0.)))
(car (cons (+ 5 10) (exit 20)))
(car (cons (+ 5 (car '(10 20))) (exit 20)))
(cons 10 20 (+ 5 "Hi"))
'()
('a)
'(a)
'(1 ('1))
(quote 1 2 3)
(qutoe 2 34 5)
; primitive predicates judgements & sequence (begin)
(atom? 1 2 3)
(atom? ())
(atom? '())
(atom? ''''''s)
(pair? '())
(pair? (cons (pair? t) (pair? (list 1 2 3))))
(pair? (list (pair? t) (pair? (list 1 2 3))))
(pair? (begin (list (pair? t) (pair? (list 1 2 3)))))
(pair? ())
(pair? '(quote . 4))
(pair? (quote()))
(pair? '())
(pair? '(3 4))
(pair? '(3 . 4))
(pair? "Hello, there!")
(list? (cons (pair? t) (pair? (list 1 2 3))))
(list? (list (pair? t) (pair? (list 1 2 3))))
(list? (begin (list (pair? t) (pair? (list 1 2 3)))))
(list? ())
(list? '(quote . 4))
(list? (quote()))
(list? (cons 1 2))
(list? 3)
(list? '(1 2 3))
(list? '(1 2 . 3))
(null? ())
(null? '())
(null? (not (atom? 0000000000)))
(null? #f)
(null? '(3 . 4))
(integer? 3)
(integer? +3)
(integer? 3.4)
(integer? -.4)
(real? 3)
(real? 3.4)
(real? .5)
(number? 3)
(number? 3.4)
(string? "Hi")
(string? +3.4)
(boolean? #t)
(boolean? ())
(boolean? #f)
(boolean? '(3 . 4))
(symbol? 'abc)
(symbol? 3)
(number? America)
(exit)